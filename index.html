<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medical Malarkey Generator</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#ff6347"/>

    <style>
        /* All CSS is the same, no changes here */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #1e1e1e; color: #f0f0f0; margin: 0; }
        header { background-color: #333; padding: 1rem; text-align: center; border-bottom: 2px solid #ff6347; }
        main { padding: 1rem; max-width: 800px; margin: auto; }
        button { background-color: #ff6347; color: white; border: none; padding: 12px 18px; border-radius: 5px; cursor: pointer; font-size: 1rem; font-weight: bold; margin-right: 8px; margin-top: 5px; }
        button:hover { background-color: #e55337; }
        button:disabled { background-color: #555; cursor: not-allowed; }
        input, textarea, select { width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #555; background-color: #333; color: white; margin-bottom: 1rem; box-sizing: border-box; font-size: 1rem; }
        textarea { min-height: 250px; white-space: pre-wrap; }
        .view { display: none; }
        .view.active { display: block; animation: fadeIn 0.5s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .hidden { display: none !important; }
        .model-selection { margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #444; }
        .model-selection label { display: block; margin-bottom: 0.5rem; font-weight: bold; }
        .model-status { font-size: 0.9em; color: #aaa; margin-top: -0.5rem; margin-bottom: 1rem; }
        #papers-list { margin-top: 1rem; }
        .paper-item { border: 1px solid #444; padding: 1rem 1rem 0.5rem 1rem; margin-bottom: 1rem; border-radius: 5px; background-color: #2a2a2a; }
        .paper-item h3 { margin-top: 0; color: #ff6347; }
        .paper-item button { margin-top: 1rem; }
        .ai-reason { background-color: #333; border-left: 3px solid #64b5f6; padding: 10px; margin: 1rem 0 0.5rem 0; border-radius: 3px; font-style: italic; color: #ccc; }
        .ai-reason strong { font-style: normal; }
        .voice-selection { margin-bottom: 1rem; display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .voice-selection label { font-weight: bold; }
        .voice-selection select { padding: 8px; border-radius: 5px; background-color: #333; color: white; border: 1px solid #555; font-size: 0.9rem; width: auto; }
        #log-container { margin-top: 2.5rem; border-top: 2px solid #555; padding-top: 1rem; }
        #log-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        #log-header h2 { margin: 0; font-size: 1.2rem; }
        #log-header button { padding: 5px 10px; font-size: 0.8rem; background-color: #555; }
        #log-output { background-color: #111; border: 1px solid #444; border-radius: 5px; padding: 10px; height: 200px; overflow-y: scroll; white-space: pre-wrap; word-wrap: break-word; font-size: 0.85rem; color: #ccc; line-height: 1.5; }
        .log-entry { margin-bottom: 4px; }
        .log-INFO { color: #f0f0f0; }
        .log-SUCCESS { color: #81c784; }
        .log-ERROR { color: #e57373; font-weight: bold; }
        .log-WARN { color: #ffd54f; }
        .log-ACTION { color: #64b5f6; font-weight: bold; }
    </style>
</head>
<body>
    <header><h1>Medical Malarkey Generator</h1></header>
    <main>
        <div id="settings-view" class="view active">
            <h2>Settings</h2>
            <p>Your API key is stored locally in your browser and is never shared.</p>
            <input type="password" id="gemini-key-input" placeholder="Enter your Gemini API Key">
            <div id="model-select-container" class="model-selection hidden">
                <label for="model-selector">Select AI Model:</label>
                <select id="model-selector"></select>
                <p id="model-status" class="model-status"></p>
            </div>
            <button id="save-key-btn">Save Key & Start</button>
        </div>
        <div id="fetch-view" class="view">
             <h2>Step 1: Find Roast-Worthy Papers</h2>
             <button id="fetch-papers-btn">Fetch & Screen Recent Papers</button>
             <div id="loader" class="hidden">
                 <p id="loader-message">Loading...</p>
             </div>
             <div id="papers-list"></div>
        </div>
        <div id="generate-view" class="view">
             <h2>Step 2: Generate Podcast Script</h2>
             <p><strong>Selected Paper:</strong> <span id="selected-paper-title"></span></p>
             <button id="generate-script-btn">Generate Roast Script!</button>
             <div id="script-loader" class="hidden">The comedy duo is conferring...</div>
             <textarea id="script-output" readonly placeholder="The generated script will appear here..."></textarea>
        </div>
        <div id="listen-view" class="view">
             <h2>Step 3: Create and Listen to the Podcast</h2>
             <div class="voice-selection"><label for="anya-voice-select">Dr. Anya Sharma's Voice:</label><select id="anya-voice-select"></select></div>
             <div class="voice-selection"><label for="ben-voice-select">Ben Carter's Voice:</label><select id="ben-voice-select"></select></div>
             <button id="speak-btn">Play Podcast Conversation</button>
             <button id="stop-btn">Stop Playback</button>
             <button id="back-to-start-btn">Start Over</button>
        </div>
        <div id="log-container">
             <div id="log-header"><h2>Event Log</h2><button id="clear-log-btn">Clear Log</button></div>
             <pre id="log-output"></pre>
        </div>
    </main>

    <script>
        // All variables and prompts are the same, no changes here
        const logOutput = document.getElementById('log-output'); function logEvent(message, type = 'INFO') { const timestamp = new Date().toLocaleTimeString(); const logEntry = document.createElement('div'); logEntry.className = `log-entry log-${type}`; logEntry.textContent = `[${timestamp} ${type}] ${message}`; logOutput.appendChild(logEntry); logOutput.scrollTop = logOutput.scrollHeight; switch (type) { case 'ERROR': console.error(`[${type}] ${message}`); break; case 'WARN': console.warn(`[${type}] ${message}`); break; default: console.log(`[${type}] ${message}`); } }
        window.addEventListener('load', () => { if ('serviceWorker' in navigator) { navigator.serviceWorker.register('service-worker.js').then(reg => logEvent('Service Worker registered.', 'SUCCESS')).catch(err => logEvent(`Service Worker registration failed: ${err}`, 'ERROR')); } initializeApp(); });
        const views = document.querySelectorAll('.view'); const geminiKeyInput = document.getElementById('gemini-key-input'); const saveKeyBtn = document.getElementById('save-key-btn'); const fetchPapersBtn = document.getElementById('fetch-papers-btn'); const papersList = document.getElementById('papers-list'); const selectedPaperTitle = document.getElementById('selected-paper-title'); const generateScriptBtn = document.getElementById('generate-script-btn'); const scriptOutput = document.getElementById('script-output'); const speakBtn = document.getElementById('speak-btn'); const stopBtn = document.getElementById('stop-btn'); const backToStartBtn = document.getElementById('back-to-start-btn'); const loader = document.getElementById('loader'); const loaderMessage = document.getElementById('loader-message'); const scriptLoader = document.getElementById('script-loader'); const anyaVoiceSelect = document.getElementById('anya-voice-select'); const benVoiceSelect = document.getElementById('ben-voice-select'); const clearLogBtn = document.getElementById('clear-log-btn'); const modelSelectContainer = document.getElementById('model-select-container'); const modelSelector = document.getElementById('model-selector'); const modelStatus = document.getElementById('model-status');
        let geminiApiKey = ''; let selectedPaper = null; let conversationalScript = []; let voices = []; let selectedModel = '';
        const GEMINI_API_URL_BASE_FOR_LISTING = 'https://generativelanguage.googleapis.com/v1beta/models'; const GEMINI_API_URL_BASE_FOR_GENERATION = 'https://generativelanguage.googleapis.com/v1beta/';
        const PAPER_SCREENER_PROMPT = `...`; const SCRIPT_GENERATOR_PROMPT = `...`; // Prompts are unchanged

        async function initializeApp() {
            logEvent('Initializing application...');
            geminiApiKey = localStorage.getItem('geminiApiKey');
            if (geminiApiKey) {
                logEvent(`Gemini API key found. Fetching models...`, 'SUCCESS');
                try {
                    await fetchAndPopulateModels(geminiApiKey);
                    // *** FIX 1: Wrap navigation in a setTimeout ***
                    logEvent('Initialization complete. Navigating to main view...');
                    setTimeout(() => {
                        showView('fetch-view');
                    }, 500); // 0.5 second delay
                } catch (error) {
                    logEvent('Initialization failed while fetching models. Staying on settings page.', 'ERROR');
                    // Stay on settings view if models fail to load
                    showView('settings-view');
                }
            } else {
                logEvent('No API key found. Showing settings.', 'WARN');
                modelSelectContainer.classList.add('hidden');
                showView('settings-view');
            }
            loadVoices();
            if (window.speechSynthesis.onvoiceschanged !== undefined) window.speechSynthesis.onvoiceschanged = loadVoices;
            saveKeyBtn.addEventListener('click', saveKeyAndStart);
            fetchPapersBtn.addEventListener('click', handleFetchAndScreenPapers);
            generateScriptBtn.addEventListener('click', handleGenerateScript);
            speakBtn.addEventListener('click', playConversationalScript);
            stopBtn.addEventListener('click', () => { window.speechSynthesis.cancel(); logEvent('Playback stopped by user.', 'ACTION'); });
            backToStartBtn.addEventListener('click', () => { logEvent('Resetting application state.', 'ACTION'); selectedPaper = null; scriptOutput.value = ''; papersList.innerHTML = ''; conversationalScript = []; showView('fetch-view'); });
            clearLogBtn.addEventListener('click', () => { logOutput.innerHTML = ''; logEvent('Log cleared.'); });
            modelSelector.addEventListener('change', handleModelChange);
        }
        
        function showView(viewId) {
            views.forEach(view => view.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
            logEvent(`Navigated to view: ${viewId}.`);
        }

        async function saveKeyAndStart() {
            const key = geminiKeyInput.value.trim();
            if (key) {
                logEvent(`API Key entered. Saving and fetching models...`, 'ACTION');
                try {
                    await fetchAndPopulateModels(key);
                    // If successful, save the key
                    localStorage.setItem('geminiApiKey', key);
                    geminiApiKey = key;
                    logEvent('Key saved and models loaded successfully.');

                    // *** FIX 2: Wrap navigation in a setTimeout ***
                    setTimeout(() => {
                        showView('fetch-view');
                    }, 500); // 0.5 second delay
                } catch (error) {
                    logEvent('Failed to validate key / fetch models. Please check the key and try again.', 'ERROR');
                    // Do not save key or navigate if there's an error.
                }
            } else {
                logEvent('Save attempt failed: key was empty.', 'WARN');
            }
        }
        
        async function fetchAndPopulateModels(apiKey) {
            logEvent("Fetching available AI models...", 'ACTION');
            modelStatus.textContent = "Fetching models...";
            modelSelectContainer.classList.remove('hidden');

            try {
                const response = await fetch(`${GEMINI_API_URL_BASE_FOR_LISTING}?key=${apiKey}`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error fetching models: ${errorData.error?.message || response.statusText}`);
                }
                const data = await response.json();
                modelSelector.innerHTML = ''; 

                const usableModels = data.models.filter(model =>
                    model.supportedGenerationMethods &&
                    model.supportedGenerationMethods.includes("generateContent") &&
                    (model.name.includes("gemini") || model.name.includes("gemma"))
                );

                if (usableModels.length === 0) {
                     throw new Error("No suitable Gemini or Gemma models found.");
                }

                usableModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.name;
                    option.textContent = model.displayName;
                    modelSelector.appendChild(option);
                });
                
                const preferredModels = ["models/gemini-1.5-flash-latest", "models/gemma-2-9b-it", "models/gemini-1.5-pro-latest"];
                let selected = false;
                for (const preferred of preferredModels) {
                    const foundOption = Array.from(modelSelector.options).find(opt => opt.value === preferred);
                    if (foundOption) {
                        modelSelector.value = preferred;
                        selected = true;
                        break;
                    }
                }
                if (!selected) modelSelector.selectedIndex = 0;
                
                handleModelChange();
                logEvent(`Found ${usableModels.length} models. Dropdown populated.`, 'SUCCESS');

            } catch (error) {
                logEvent(`Error fetching models: ${error.message}`, 'ERROR');
                modelStatus.textContent = "Error loading models. Check key or permissions.";
                modelSelectContainer.classList.add('hidden');
                // IMPORTANT: Re-throw the error so the calling function knows it failed.
                throw error;
            }
        }

        // All subsequent functions are unchanged
        function handleModelChange() { if (modelSelector.value) { selectedModel = modelSelector.value; const displayName = modelSelector.options[modelSelector.selectedIndex].text; modelStatus.textContent = `Using: ${displayName}`; logEvent(`AI Model changed to: ${selectedModel}`, 'ACTION'); } }
        function loadVoices() { voices = window.speechSynthesis.getVoices(); if (voices.length === 0) { logEvent('Speech synthesis voices not yet available. Waiting for onvoiceschanged.', 'WARN'); return; } anyaVoiceSelect.innerHTML = ''; benVoiceSelect.innerHTML = ''; voices.filter(v => v.lang.startsWith('en')).forEach(v => { const opt = document.createElement('option'); opt.textContent = `${v.name} (${v.lang})`; opt.setAttribute('data-name', v.name); anyaVoiceSelect.appendChild(opt.cloneNode(true)); benVoiceSelect.appendChild(opt.cloneNode(true)); }); const anyaIdx = voices.findIndex(v => v.name === 'Google US English' || v.name.includes('Ava')); const benIdx = voices.findIndex(v => v.name === 'Microsoft David - English (United States)' || v.name.includes('Andrew')); anyaVoiceSelect.selectedIndex = anyaIdx !== -1 ? anyaIdx : 0; benVoiceSelect.selectedIndex = benIdx !== -1 ? benIdx : 1; logEvent('Voices loaded and dropdowns populated.', 'SUCCESS'); }
        async function getRoastabilityScore(paper) { const filledPrompt = PAPER_SCREENER_PROMPT.replace('{TITLE}', paper.title).replace('{ABSTRACT}', paper.abstract); try { const geminiApiUrl = `${GEMINI_API_URL_BASE_FOR_GENERATION}${selectedModel}:generateContent?key=${geminiApiKey}`; const response = await fetch(geminiApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: filledPrompt }] }] }) }); if (!response.ok) { const errorText = await response.text(); throw new Error(`Gemini screening API returned ${response.status}: ${errorText}`); } const data = await response.json(); if (!data.candidates || !data.candidates[0] || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) { throw new Error("Invalid response structure from Gemini screening API."); } const cleanJsonText = data.candidates[0].content.parts[0].text.trim().replace(/^```json/, '').replace(/```$/, '').trim(); const result = JSON.parse(cleanJsonText); return { ...paper, score: parseInt(result.score, 10) || 0, reason: result.reason || "No reason provided." }; } catch (error) { logEvent(`Failed to screen paper "${paper.title.substring(0,20)}...": ${error.message}`, 'ERROR'); return { ...paper, score: 0, reason: "Analysis failed due to error." }; } }
        async function handleFetchAndScreenPapers() { logEvent('Starting paper fetch and screen process...', 'ACTION'); loader.classList.remove('hidden'); fetchPapersBtn.disabled = true; papersList.innerHTML = ''; let allFetchedPapers = []; try { loaderMessage.textContent = 'Fetching recent papers from PubMed...'; const sixMonthsAgo = new Date(); sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6); const dateStr = `${sixMonthsAgo.getFullYear()}/${(sixMonthsAgo.getMonth() + 1).toString().padStart(2, '0')}/${sixMonthsAgo.getDate().toString().padStart(2, '0')}`; const searchQuery = `(("BMJ"[Journal]) OR ("The Lancet"[Journal]) OR ("New England Journal of Medicine"[Journal])) AND ("${dateStr}"[Date - Publication] : "3000"[Date - Publication]) AND "free full text"[Filter]`; const searchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=${encodeURIComponent(searchQuery)}&retmode=json&retmax=50`; const searchResponse = await fetch(searchUrl); if (!searchResponse.ok) throw new Error(`PubMed esearch failed: ${searchResponse.status}`); const searchData = await searchResponse.json(); const paperIds = searchData.esearchresult.idlist; if (!paperIds || paperIds.length === 0) { throw new Error("No papers found from PubMed matching criteria."); } logEvent(`Fetched ${paperIds.length} paper IDs from PubMed. Now getting details.`); const fetchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${paperIds.join(',')}&retmode=xml`; const fetchResponse = await fetch(fetchUrl); if (!fetchResponse.ok) throw new Error(`PubMed efetch failed: ${fetchResponse.status}`); const xmlText = await fetchResponse.text(); const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlText, "application/xml"); const articles = xmlDoc.getElementsByTagName('PubmedArticle'); for (const article of articles) { allFetchedPapers.push({ title: article.getElementsByTagName('ArticleTitle')[0]?.textContent || 'No Title', abstract: article.getElementsByTagName('AbstractText')[0]?.textContent || 'No Abstract Available', journal: article.getElementsByTagName('Title')[0]?.textContent || 'N/A' }); } } catch (error) { logEvent(`Failed during PubMed fetch: ${error.message}`, 'ERROR'); loader.classList.add('hidden'); fetchPapersBtn.disabled = false; papersList.innerHTML = `<p style="color:#e57373;">Failed to fetch papers from PubMed. Check Event Log.</p>`; return; } if (allFetchedPapers.length === 0) { logEvent('No paper details could be extracted from PubMed fetch, though IDs were found.', 'WARN'); loader.classList.add('hidden'); fetchPapersBtn.disabled = false; papersList.innerHTML = `<p>No paper details found from PubMed. Try again.</p>`; return; } loaderMessage.textContent = `Asking AI to screen ${allFetchedPapers.length} papers...`; logEvent(`Screening ${allFetchedPapers.length} papers with ${selectedModel}. This may take a moment...`, 'ACTION'); const screeningPromises = allFetchedPapers.map(paper => getRoastabilityScore(paper)); let screenedPapers = []; try { screenedPapers = await Promise.all(screeningPromises); } catch (error) { logEvent(`Error during Promise.all for screening: ${error.message}`, 'ERROR'); loader.classList.add('hidden'); fetchPapersBtn.disabled = false; papersList.innerHTML = `<p style="color:#e57373;">Error during AI screening. Check Event Log.</p>`; return; } const roastablePapers = screenedPapers.filter(p => p.score >= 6).sort((a, b) => b.score - a.score); logEvent(`Screening complete. Found ${roastablePapers.length} high-potential papers (score >= 6).`, 'SUCCESS'); if (roastablePapers.length === 0) { papersList.innerHTML = '<p>The AI scout reviewed the latest papers and found nothing weird enough to roast today. Try again later!</p>'; } else { roastablePapers.forEach(paperData => { const paperElement = document.createElement('div'); paperElement.className = 'paper-item'; paperElement.innerHTML = `<h3>${paperData.title}</h3><p><strong>Journal:</strong> ${paperData.journal}</p><div class="ai-reason"><strong>AI Scout's Notes (Score: ${paperData.score}/10):</strong> ${paperData.reason}</div><button>Roast This Paper</button>`; paperElement.querySelector('button').onclick = () => { selectedPaper = paperData; selectedPaperTitle.textContent = paperData.title; logEvent(`Paper selected for roasting: "${paperData.title}"`, 'ACTION'); showView('generate-view'); }; papersList.appendChild(paperElement); }); } loader.classList.add('hidden'); fetchPapersBtn.disabled = false; }
        async function handleGenerateScript() { if (!selectedPaper) return; logEvent(`Generating script with ${selectedModel}...`, 'ACTION'); scriptLoader.classList.remove('hidden'); generateScriptBtn.disabled = true; scriptOutput.value = ''; const filledPrompt = SCRIPT_GENERATOR_PROMPT.replace('{TITLE}', selectedPaper.title).replace('{ABSTRACT}', selectedPaper.abstract); try { const geminiApiUrl = `${GEMINI_API_URL_BASE_FOR_GENERATION}${selectedModel}:generateContent?key=${geminiApiKey}`; const response = await fetch(geminiApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: filledPrompt }] }] }) }); if (!response.ok) { const errBody = await response.text(); throw new Error(`API Error: ${response.status}. ${errBody}`); } const data = await response.json(); if (!data.candidates || !data.candidates[0] || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) { throw new Error("Invalid response structure from Gemini script generation API."); } const rawText = data.candidates[0].content.parts[0].text; logEvent('Received response from Gemini.'); const cleanJsonText = rawText.trim().replace(/^```json/, '').replace(/```$/, '').trim(); conversationalScript = JSON.parse(cleanJsonText); scriptOutput.value = conversationalScript.map(turn => `${turn.speaker}: ${turn.line}`).join('\n\n'); logEvent(`Script generated successfully with ${conversationalScript.length} lines.`, 'SUCCESS'); showView('listen-view'); } catch (error) { logEvent(`Failed to generate script: ${error.message}`, 'ERROR'); showView('generate-view'); } finally { scriptLoader.classList.add('hidden'); generateScriptBtn.disabled = false; } }
        function playConversationalScript() { if (conversationalScript.length === 0 || !('speechSynthesis' in window)) { logEvent('Cannot play script: No script loaded or speech synthesis not supported.', 'ERROR'); return; } logEvent('Starting podcast playback...', 'ACTION'); window.speechSynthesis.cancel(); speakTurn(0); }
        function speakTurn(turnIndex) { if (turnIndex >= conversationalScript.length) { logEvent('Playback finished.', 'SUCCESS'); return; } const turn = conversationalScript[turnIndex]; const utterance = new SpeechSynthesisUtterance(turn.line); const selectedVoiceName = turn.speaker === 'Anya' ? anyaVoiceSelect.selectedOptions[0].getAttribute('data-name') : benVoiceSelect.selectedOptions[0].getAttribute('data-name'); utterance.voice = voices.find(v => v.name === selectedVoiceName); if (!utterance.voice && voices.length > 0) { logEvent(`Voice "${selectedVoiceName}" not found. Using default.`, 'WARN'); utterance.voice = voices[0]; } utterance.rate = 0.95; utterance.pitch = turn.speaker === 'Anya' ? 1.0 : 1.1; utterance.onstart = () => logEvent(`Speaking line ${turnIndex + 1}/${conversationalScript.length} (Speaker: ${turn.speaker})`); utterance.onend = () => speakTurn(turnIndex + 1); utterance.onerror = e => logEvent(`Speech synthesis error: ${e.error}`, 'ERROR'); window.speechSynthesis.speak(utterance); }
    </script>
</body>
</html>