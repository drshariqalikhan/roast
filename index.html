<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medical Malarkey Generator</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#ff6347"/>

    <style>
        /* Basic styling */
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1e1e1e; 
            color: #f0f0f0; 
            margin: 0; 
        }
        header { 
            background-color: #333; 
            padding: 1rem; 
            text-align: center; 
            border-bottom: 2px solid #ff6347;
        }
        main { 
            padding: 1rem; 
            max-width: 800px; 
            margin: auto; 
        }
        button { 
            background-color: #ff6347; 
            color: white; 
            border: none; 
            padding: 12px 18px; 
            border-radius: 5px; 
            cursor: pointer; 
            font-size: 1rem;
            font-weight: bold;
            margin-right: 8px;
            margin-top: 5px;
        }
        button:hover { 
            background-color: #e55337; 
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        input, textarea { 
            width: 100%; 
            padding: 10px; 
            border-radius: 5px; 
            border: 1px solid #555; 
            background-color: #333; 
            color: white; 
            margin-bottom: 1rem; 
            box-sizing: border-box;
            font-size: 1rem;
        }
        textarea { 
            min-height: 250px; 
            white-space: pre-wrap;
        }

        /* View Management */
        .view { display: none; }
        .view.active { display: block; animation: fadeIn 0.5s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .hidden { display: none !important; }

        /* Paper List Styling */
        #papers-list { margin-top: 1rem; }
        .paper-item { 
            border: 1px solid #444; 
            padding: 1rem 1rem 0.5rem 1rem; 
            margin-bottom: 1rem; 
            border-radius: 5px; 
            background-color: #2a2a2a;
        }
        .paper-item h3 { margin-top: 0; color: #ff6347; }
        .paper-item button { margin-top: 1rem; }
        
        /* Styling for the AI's reason */
        .ai-reason {
            background-color: #333;
            border-left: 3px solid #64b5f6;
            padding: 10px;
            margin: 1rem 0 0.5rem 0;
            border-radius: 3px;
            font-style: italic;
            color: #ccc;
        }
        .ai-reason strong {
            font-style: normal;
        }


        /* Voice Selection Styling */
        .voice-selection {
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .voice-selection label {
            font-weight: bold;
        }
        select {
            padding: 8px;
            border-radius: 5px;
            background-color: #333;
            color: white;
            border: 1px solid #555;
            font-size: 0.9rem;
        }

        /* Event Log Styling */
        #log-container { margin-top: 2.5rem; border-top: 2px solid #555; padding-top: 1rem; }
        #log-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        #log-header h2 { margin: 0; font-size: 1.2rem; }
        #log-header button { padding: 5px 10px; font-size: 0.8rem; background-color: #555; }
        #log-output { background-color: #111; border: 1px solid #444; border-radius: 5px; padding: 10px; height: 200px; overflow-y: scroll; white-space: pre-wrap; word-wrap: break-word; font-size: 0.85rem; color: #ccc; line-height: 1.5; }
        .log-entry { margin-bottom: 4px; }
        .log-INFO { color: #f0f0f0; }
        .log-SUCCESS { color: #81c784; }
        .log-ERROR { color: #e57373; font-weight: bold; }
        .log-WARN { color: #ffd54f; }
        .log-ACTION { color: #64b5f6; font-weight: bold; }

    </style>
</head>
<body>
    <header><h1>Medical Malarkey Generator</h1></header>
    <main>
        <div id="settings-view" class="view active">
            <h2>Settings</h2>
            <p>Your API key is stored locally in your browser and is never shared.</p>
            <input type="password" id="gemini-key-input" placeholder="Enter your Gemini API Key">
            <button id="save-key-btn">Save Key & Start</button>
        </div>
        <div id="fetch-view" class="view">
            <h2>Step 1: Find Roast-Worthy Papers</h2>
            <button id="fetch-papers-btn">Fetch & Screen Recent Papers</button>
            <div id="loader" class="hidden">
                <p id="loader-message">Loading...</p>
            </div>
            <div id="papers-list"></div>
        </div>
        <div id="generate-view" class="view">
            <h2>Step 2: Generate Podcast Script</h2>
            <p><strong>Selected Paper:</strong> <span id="selected-paper-title"></span></p>
            <button id="generate-script-btn">Generate Roast Script!</button>
            <div id="script-loader" class="hidden">The comedy duo is conferring...</div>
            <textarea id="script-output" readonly placeholder="The generated script will appear here..."></textarea>
        </div>
        <div id="listen-view" class="view">
            <h2>Step 3: Create and Listen to the Podcast</h2>
             <div class="voice-selection"><label for="anya-voice-select">Dr. Anya Sharma's Voice:</label><select id="anya-voice-select"></select></div>
             <div class="voice-selection"><label for="ben-voice-select">Ben Carter's Voice:</label><select id="ben-voice-select"></select></div>
            <button id="speak-btn">Play Podcast Conversation</button>
            <button id="stop-btn">Stop Playback</button>
            <button id="back-to-start-btn">Start Over</button>
        </div>
        <div id="log-container">
            <div id="log-header"><h2>Event Log</h2><button id="clear-log-btn">Clear Log</button></div>
            <pre id="log-output"></pre>
        </div>
    </main>

    <!-- The <script> tag is now correctly placed AFTER the closing </style> tag and before </body> -->
    <script>
        const logOutput = document.getElementById('log-output');

        function logEvent(message, type = 'INFO') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp} ${type}] ${message}`;
            logOutput.appendChild(logEntry);
            logOutput.scrollTop = logOutput.scrollHeight;
            
            switch (type) {
                case 'ERROR': console.error(`[${type}] ${message}`); break;
                case 'WARN': console.warn(`[${type}] ${message}`); break;
                default: console.log(`[${type}] ${message}`);
            }
        }
        
        window.addEventListener('load', () => {
          if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js') // Path relative to index.html
              .then(reg => logEvent('Service Worker registered.', 'SUCCESS'))
              .catch(err => logEvent(`Service Worker registration failed: ${err}`, 'ERROR'));
          }
          initializeApp();
        });
        
        const views = document.querySelectorAll('.view');
        const geminiKeyInput = document.getElementById('gemini-key-input');
        const saveKeyBtn = document.getElementById('save-key-btn');
        const fetchPapersBtn = document.getElementById('fetch-papers-btn');
        const papersList = document.getElementById('papers-list');
        const selectedPaperTitle = document.getElementById('selected-paper-title');
        const generateScriptBtn = document.getElementById('generate-script-btn');
        const scriptOutput = document.getElementById('script-output');
        const speakBtn = document.getElementById('speak-btn');
        const stopBtn = document.getElementById('stop-btn');
        const backToStartBtn = document.getElementById('back-to-start-btn');
        const loader = document.getElementById('loader');
        const loaderMessage = document.getElementById('loader-message');
        const scriptLoader = document.getElementById('script-loader');
        const anyaVoiceSelect = document.getElementById('anya-voice-select');
        const benVoiceSelect = document.getElementById('ben-voice-select');
        const clearLogBtn = document.getElementById('clear-log-btn');

        let geminiApiKey = '';
        let selectedPaper = null;
        let conversationalScript = [];
        let voices = [];

        const PAPER_SCREENER_PROMPT = `
        **ROLE:** You are a cynical and witty comedy scout for a podcast that roasts weird medical research. Your job is to screen paper abstracts and give them a "Roastability Score."
        **TASK:** Analyze the following Title and Abstract. Based on the criteria below, provide a "Roastability Score" from 1 (boring) to 10 (comedy gold).
        **CRITERIA FOR A HIGH SCORE:**
        - **Absurd Premise:** Is the core research question bizarre, trivial, or on a topic no one would think to study?
        - **Far-Fetched Methodology:** Does the method sound strange or overly complicated for a simple problem?
        - **Clinically Useless Conclusion:** Is the final conclusion technically true but utterly useless in the real world?
        **INPUT:**
        - **Title:** "{TITLE}"
        - **Abstract:** "{ABSTRACT}"
        **OUTPUT FORMAT:** You MUST reply only with a single, valid JSON object containing two keys: "score" (an integer from 1 to 10) and "reason" (a brief, one-sentence explanation for your score, written in a witty tone).
        **EXAMPLE OUTPUT:**
        {"score":9,"reason":"The study's focus on the aerodynamic properties of a dropped piece of buttered toast is a classic example of gloriously useless science."}
        `;

        const SCRIPT_GENERATOR_PROMPT = `
        **ROLES & PERSONAS:**
        - **Dr. Anya Sharma:** The "straight man." She is a sharp, witty, and knowledgeable scientist. She understands the paper's jargon and explains the premise, but with a deeply sarcastic and cynical edge. Her humor is dry and intellectual.
        - **Ben Carter:** The "chaos agent." He is an everyman who is constantly baffled by the science. He makes wild, relatable analogies, asks the "dumb" questions everyone is thinking, and generally brings high energy and incredulity. His humor is broad and observational.
        **TASK:** Write a humorous, conversational podcast script of about 600-800 words where Dr. Anya Sharma and Ben Carter roast the provided medical research paper.
        **CONTEXT:** The show is called "Lab Laughs." Anya introduces the paper, and Ben reacts. They go back and forth, dissecting the paper's premise, methods, and useless conclusion in a conversational style.
        **INPUT PAPER DETAILS:**
        - **Title:** "{TITLE}"
        - **Abstract:** "{ABSTRACT}"
        **OUTPUT FORMAT:** Reply with only a valid JSON array of objects. Each object must have two keys: "speaker" (either "Anya" or "Ben") and "line" (the dialogue). Do not include any text before or after the JSON array.
        `;

        function initializeApp() {
            logEvent('Initializing application...');
            geminiApiKey = localStorage.getItem('geminiApiKey');
            if (geminiApiKey) {
                logEvent('Gemini API key found.', 'SUCCESS');
                showView('fetch-view');
            } else {
                logEvent('No API key found. Showing settings.', 'WARN');
                showView('settings-view');
            }
            loadVoices();
            if (window.speechSynthesis.onvoiceschanged !== undefined) window.speechSynthesis.onvoiceschanged = loadVoices;
            saveKeyBtn.addEventListener('click', saveKeyAndStart);
            fetchPapersBtn.addEventListener('click', handleFetchAndScreenPapers);
            generateScriptBtn.addEventListener('click', handleGenerateScript);
            speakBtn.addEventListener('click', playConversationalScript);
            stopBtn.addEventListener('click', () => {
                window.speechSynthesis.cancel();
                logEvent('Playback stopped by user.', 'ACTION');
            });
            backToStartBtn.addEventListener('click', () => {
                logEvent('Resetting application state.', 'ACTION');
                selectedPaper = null;
                scriptOutput.value = '';
                papersList.innerHTML = '';
                conversationalScript = [];
                showView('fetch-view');
            });
            clearLogBtn.addEventListener('click', () => { logOutput.innerHTML = ''; logEvent('Log cleared.'); });
        }
        
        function showView(viewId) {
            views.forEach(view => view.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
            logEvent(`Navigated to view: ${viewId}.`);
        }

        function saveKeyAndStart() {
            const key = geminiKeyInput.value.trim();
            if (key) {
                localStorage.setItem('geminiApiKey', key);
                geminiApiKey = key;
                logEvent('API Key saved.', 'SUCCESS');
                showView('fetch-view');
            } else {
                logEvent('Save attempt failed: key was empty.', 'WARN');
            }
        }

        function loadVoices() {
            voices = window.speechSynthesis.getVoices();
            if (voices.length === 0) {
                 logEvent('Speech synthesis voices not yet available. Waiting for onvoiceschanged.', 'WARN');
                 return; 
            }
            anyaVoiceSelect.innerHTML = '';
            benVoiceSelect.innerHTML = '';
            voices.filter(v => v.lang.startsWith('en')).forEach(v => {
                const opt = document.createElement('option');
                opt.textContent = `${v.name} (${v.lang})`;
                opt.setAttribute('data-name', v.name);
                anyaVoiceSelect.appendChild(opt.cloneNode(true));
                benVoiceSelect.appendChild(opt.cloneNode(true));
            });
            const anyaIdx = voices.findIndex(v => v.name === 'Google US English' || v.name.includes('Female'));
            const benIdx = voices.findIndex(v => v.name === 'Microsoft David - English (United States)' || v.name.includes('Male'));
            anyaVoiceSelect.selectedIndex = anyaIdx !== -1 ? anyaIdx : 0;
            benVoiceSelect.selectedIndex = benIdx !== -1 ? benIdx : 1;
            logEvent('Voices loaded and dropdowns populated.', 'SUCCESS');
        }

        async function getRoastabilityScore(paper) {
            const filledPrompt = PAPER_SCREENER_PROMPT
                .replace('{TITLE}', paper.title)
                .replace('{ABSTRACT}', paper.abstract);
            try {
                const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${geminiApiKey}`;
                const response = await fetch(geminiApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: filledPrompt }] }] })
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Gemini screening API returned ${response.status}: ${errorText}`);
                }
                const data = await response.json();
                if (!data.candidates || !data.candidates[0] || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) {
                    throw new Error("Invalid response structure from Gemini screening API.");
                }
                const cleanJsonText = data.candidates[0].content.parts[0].text.trim().replace(/^```json/, '').replace(/```$/, '').trim();
                const result = JSON.parse(cleanJsonText);
                return { ...paper, score: parseInt(result.score, 10) || 0, reason: result.reason || "No reason provided." };
            } catch (error) {
                logEvent(`Failed to screen paper "${paper.title.substring(0,20)}...": ${error.message}`, 'ERROR');
                return { ...paper, score: 0, reason: "Analysis failed due to error." };
            }
        }
        
        async function handleFetchAndScreenPapers() {
            logEvent('Starting paper fetch and screen process...', 'ACTION');
            loader.classList.remove('hidden');
            fetchPapersBtn.disabled = true;
            papersList.innerHTML = '';

            let allFetchedPapers = [];
            try {
                loaderMessage.textContent = 'Fetching recent papers from PubMed...';
                const sixMonthsAgo = new Date();
                sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
                const dateStr = `${sixMonthsAgo.getFullYear()}/${(sixMonthsAgo.getMonth() + 1).toString().padStart(2, '0')}/${sixMonthsAgo.getDate().toString().padStart(2, '0')}`;
                const searchQuery = `(("BMJ"[Journal]) OR ("The Lancet"[Journal]) OR ("New England Journal of Medicine"[Journal])) AND ("${dateStr}"[Date - Publication] : "3000"[Date - Publication]) AND "free full text"[Filter]`;
                const searchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=${encodeURIComponent(searchQuery)}&retmode=json&retmax=50`;
                const searchResponse = await fetch(searchUrl);
                if (!searchResponse.ok) throw new Error(`PubMed esearch failed: ${searchResponse.status}`);
                const searchData = await searchResponse.json();
                const paperIds = searchData.esearchresult.idlist;

                if (!paperIds || paperIds.length === 0) {
                    throw new Error("No papers found from PubMed matching criteria.");
                }

                logEvent(`Fetched ${paperIds.length} paper IDs from PubMed. Now getting details.`);
                const fetchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${paperIds.join(',')}&retmode=xml`;
                const fetchResponse = await fetch(fetchUrl);
                if (!fetchResponse.ok) throw new Error(`PubMed efetch failed: ${fetchResponse.status}`);
                const xmlText = await fetchResponse.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "application/xml");
                const articles = xmlDoc.getElementsByTagName('PubmedArticle');
                
                for (const article of articles) {
                    allFetchedPapers.push({
                        title: article.getElementsByTagName('ArticleTitle')[0]?.textContent || 'No Title',
                        abstract: article.getElementsByTagName('AbstractText')[0]?.textContent || 'No Abstract Available',
                        journal: article.getElementsByTagName('Title')[0]?.textContent || 'N/A'
                    });
                }
            } catch (error) {
                logEvent(`Failed during PubMed fetch: ${error.message}`, 'ERROR');
                loader.classList.add('hidden');
                fetchPapersBtn.disabled = false;
                papersList.innerHTML = `<p style="color:#e57373;">Failed to fetch papers from PubMed. Check Event Log.</p>`;
                return;
            }

            if (allFetchedPapers.length === 0) {
                logEvent('No paper details could be extracted from PubMed fetch, though IDs were found.', 'WARN');
                loader.classList.add('hidden');
                fetchPapersBtn.disabled = false;
                papersList.innerHTML = `<p>No paper details found from PubMed. Try again.</p>`;
                return;
            }

            loaderMessage.textContent = `Asking AI to screen ${allFetchedPapers.length} papers...`;
            logEvent(`Screening ${allFetchedPapers.length} papers with Gemini. This may take a moment...`, 'ACTION');
            
            const screeningPromises = allFetchedPapers.map(paper => getRoastabilityScore(paper));
            let screenedPapers = [];
            try {
                screenedPapers = await Promise.all(screeningPromises);
            } catch (error) {
                logEvent(`Error during Promise.all for screening: ${error.message}`, 'ERROR');
                loader.classList.add('hidden');
                fetchPapersBtn.disabled = false;
                papersList.innerHTML = `<p style="color:#e57373;">Error during AI screening. Check Event Log.</p>`;
                return;
            }
            

            const roastablePapers = screenedPapers
                .filter(p => p.score >= 6) // Minimum score threshold
                .sort((a, b) => b.score - a.score);

            logEvent(`Screening complete. Found ${roastablePapers.length} high-potential papers (score >= 6).`, 'SUCCESS');

            if (roastablePapers.length === 0) {
                papersList.innerHTML = '<p>The AI scout reviewed the latest papers and found nothing weird enough to roast today. Try again later!</p>';
            } else {
                roastablePapers.forEach(paperData => {
                    const paperElement = document.createElement('div');
                    paperElement.className = 'paper-item';
                    paperElement.innerHTML = `
                        <h3>${paperData.title}</h3>
                        <p><strong>Journal:</strong> ${paperData.journal}</p>
                        <div class="ai-reason">
                            <strong>AI Scout's Notes (Score: ${paperData.score}/10):</strong> 
                            ${paperData.reason}
                        </div>
                        <button>Roast This Paper</button>
                    `;
                    paperElement.querySelector('button').onclick = () => {
                        selectedPaper = paperData;
                        selectedPaperTitle.textContent = paperData.title;
                        logEvent(`Paper selected for roasting: "${paperData.title}"`, 'ACTION');
                        showView('generate-view');
                    };
                    papersList.appendChild(paperElement);
                });
            }

            loader.classList.add('hidden');
            fetchPapersBtn.disabled = false;
        }
        
        async function handleGenerateScript() {
            if (!selectedPaper) return;
            logEvent('Generating script with Gemini API...', 'ACTION');
            scriptLoader.classList.remove('hidden');
            generateScriptBtn.disabled = true;
            scriptOutput.value = '';
            const filledPrompt = SCRIPT_GENERATOR_PROMPT.replace('{TITLE}', selectedPaper.title).replace('{ABSTRACT}', selectedPaper.abstract);
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${geminiApiKey}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: filledPrompt }] }] })
                });
                if (!response.ok) { const errBody = await response.text(); throw new Error(`API Error: ${response.status}. ${errBody}`); }
                const data = await response.json();
                 if (!data.candidates || !data.candidates[0] || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) {
                    throw new Error("Invalid response structure from Gemini script generation API.");
                }
                const rawText = data.candidates[0].content.parts[0].text;
                logEvent('Received response from Gemini.');
                const cleanJsonText = rawText.trim().replace(/^```json/, '').replace(/```$/, '').trim();
                conversationalScript = JSON.parse(cleanJsonText);
                scriptOutput.value = conversationalScript.map(turn => `${turn.speaker}: ${turn.line}`).join('\n\n');
                logEvent(`Script generated successfully with ${conversationalScript.length} lines.`, 'SUCCESS');
                showView('listen-view');
            } catch (error) {
                logEvent(`Failed to generate script: ${error.message}`, 'ERROR');
                showView('generate-view');
            } finally {
                scriptLoader.classList.add('hidden');
                generateScriptBtn.disabled = false;
            }
        }
        function playConversationalScript() {
            if (conversationalScript.length === 0 || !('speechSynthesis' in window)) {
                 logEvent('Cannot play script: No script loaded or speech synthesis not supported.', 'ERROR');
                return;
            }
            logEvent('Starting podcast playback...', 'ACTION');
            window.speechSynthesis.cancel();
            speakTurn(0);
        }
        function speakTurn(turnIndex) {
            if (turnIndex >= conversationalScript.length) { logEvent('Playback finished.', 'SUCCESS'); return; }
            const turn = conversationalScript[turnIndex];
            const utterance = new SpeechSynthesisUtterance(turn.line);
            const selectedVoiceName = turn.speaker === 'Anya' ? anyaVoiceSelect.selectedOptions[0].getAttribute('data-name') : benVoiceSelect.selectedOptions[0].getAttribute('data-name');
            utterance.voice = voices.find(v => v.name === selectedVoiceName);
            if (!utterance.voice && voices.length > 0) { 
                logEvent(`Voice "${selectedVoiceName}" not found. Using default.`, 'WARN');
                utterance.voice = voices[0]; 
            }
            utterance.rate = 0.95;
            utterance.pitch = turn.speaker === 'Anya' ? 1.0 : 1.1;
            utterance.onstart = () => logEvent(`Speaking line ${turnIndex + 1}/${conversationalScript.length} (Speaker: ${turn.speaker})`);
            utterance.onend = () => speakTurn(turnIndex + 1);
            utterance.onerror = e => logEvent(`Speech synthesis error: ${e.error}`, 'ERROR');
            window.speechSynthesis.speak(utterance);
        }
    </script>
</body>
</html>